---
title: 大佬们的面试总结
date: 2018-10-31 10:25:41
tags:
---

# 大佬总结  

1. [来之不易的美团面试，结果居然挂了...（附面试答案）](https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&mid=2247484751&idx=1&sn=8616aece193d174c12757d22e3e04924&chksm=96cd4503a1bacc154aceaaa89cdb8eeb4c2a83a459df0edb2c5380579aa46a946a94bfa1dac1&mpshare=1&scene=23&srcid=1031r9yw90bnnqcakGdQ3zjC#rd)  

> 非常口语化的描述了面试问题和答案，非常赞，包含了java基础知识、数据结构、多线程、内存机制、垃圾回收等常见面试点。  

2. [算法经典面试题整理（java实现）](https://blog.csdn.net/huangshulang1234/article/details/79523258)  

3. [数据结构-算法博客](https://www.cnblogs.com/skywang12345/category/508186.html)  

# 分布式事务  

``Spring事务``本质是单机下的事务，是由数据库本身保证的。  
``分布式事务``本质上犹豫业务拆分，数据库分库分表，一个业务操作中保证多个数据库的事务进行统一控制。  

参考博客：[分布式](https://github.com/Snailclimb/JavaGuide/blob/master/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F.md)  

## CAP原理  

一致性、可用性、分区容错性。  

## 事务补偿和回滚  

1. 因为事务是原子性的，回滚是事务提交前，没有提交，导致数据库并没有修改过。  
2. 补偿的话是数据库已经修改过一次,然后再做一次相反的操作,从而达到前一次的修改看起来没有执行,实际上已经进行过两次修改了。  

## TCC事务补偿  

核心思想：针对每一个分布式事务操作，都要注册一个与其对应的确认和补偿（撤销）操作。  

1. Try 阶段主要是对业务系统做检测及资源预留  

2. Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。  

3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。  

> 比如更新订单时，同时扣减账户资金和库存  

1. Try阶段，扣减账户资金，同时设置冻结资金，即扣减的总额；  
2. Confirm阶段，解冻冻结的扣减资金，即数据库中设置为0；  
3. Cancel阶段，账户资金恢复到原来扣减前的，同时解冻冻结的扣减资金，即数据库中设置为0；  


### 异常  

当try方法的AOP切面有异常的时候，采用线程池异步去执行cancel，无异常的时候去执行confrim方法。

这里有人可能会问：那么cancel方法异常，或者confrim方法异常怎么办呢？
答：首先这种情况是非常罕见的，因为你上一面才刚刚执行完try。其次如果出现这种情况，在try阶段会保存好日志，Hmily有内置的调度线程池来进行恢复，不用担心。  


# mysql  

## 插入百万级别数据  

参考博客：[JDBC实现往MySQL插入百万级数据](https://www.cnblogs.com/fnz0/p/5713102.html)  

## 索引  

参考：[数据库索引的实现原理](数据库索引的实现原理)  

唯一索引、主键索引、聚集索引。  

* 优点：  
> 索引是对于查询的优化，其数据机构为``B树``及其变种``B+树``，运用二叉查找在O(log2n)的复杂度内获取数据；而一般的顺序查找时间复杂度为O(n)。  
> 举个例子：表中有一百万条数据，需要在其中寻找一条特定id的数据。如果顺序查找，平均需要查找50万条数据。而用二分法，至多不超过20次就能找到。二者的效率差了2.5万倍！  
> 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性；  

* 缺点：  
> 一是增加了数据库的存储空间；  
> 二是在插入和修改数据时要花费较多的时间更新索引。  

* 合理运用  
> 在经常需要搜索的列上，加快搜索的速度；  
> 主键；  
> 在经常需要根据范围、排序的列上创建索引，因为索引已经排序；  
> 在经常使用在``WHERE``子句上的列上面创建索引，加快条件的判断速度。  

## 锁、事务和并发控制    

参考博客：[深入理解Mysql——锁、事务与并发控制](https://blog.csdn.net/lemon89/article/details/51477497)  


每个连接都会在mysql服务端产生一个线程（内部通过线程池管理线程），比如一个select语句进入，mysql首先会在查询缓存中查找是否缓存了这个select的结果集，如果没有则继续执行 解析、优化、执行的过程；否则会之间从缓存中获取结果集。  

### 并发控制-共享锁、排他锁  

* 共享锁  
> 共享锁也称为读锁，读锁允许多个连接可以同一时刻并发的读取统一资源，互不干扰。  

* 排他锁  
> 排他锁也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。  

* 锁策略--表锁
> 锁的开销是较为昂贵的，锁策略其实就是保证了线程安全的同时获取最大的性能之间的平衡策略。  
> 写操作：一个用户正在执行写操作，会获取排他的``写锁``，锁定整个表，阻塞其他用户的读、写操作。  
> 读操作：一个用户正在执行读操作，会获取共享的``读锁``，其他用户只要没有写操作，可以并发读取统一资源。  

* 锁策略--行锁  
> 行锁可以最大限度的支持并发处理，当然也带来了最大开销，顾名思义，行锁的粒度实在每一条行数据。  

### 事务  

事务就是说，要么mysql引擎会全部执行这一组sql语句，要么全部都不执行（比如其中一条语句失败的话）。  
mysql默认采用AutoCommit模式，也就是每个sql都是一个事务，并不需要显示的执行事务。
如果autoCommit关闭，那么每个sql都默认开启一个事务，只有显式的执行“commit”后这个事务才会被提交。  

#### ACIO  

A:atomiciy原子性 
一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。

C:consistency一致性 
数据必须保证从一种一致性的状态转换为另一种一致性状态。 
比如上一个事务中执行了第二步时系统崩溃了，数据也不会出现bill的账户少了100块，但是tim的账户没变的情况。要么维持原装（全部回滚），要么bill少了100块同时tim多了100块，只有这两种一致性状态的

I：isolation隔离性 
在一个事务未执行完毕时，通常会保证其他Session 无法看到这个事务的执行结果

D:durability持久性 
事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。  

#### 事务并发问题  

1. 脏读  
> 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。  

2. 幻读  
> 一个事务读取数据行数，第二个事务新增或删除一行数据，第一个事务再次读取发现表记录数不一样了。  

3. 不可重复读  
> 一个事务内，多次读统一数据之间，如果该事务没有结束，另一个事务修改了该数据，第一个事务两次读到的数据可能就是不一样的。  

* 提醒：  
> 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了  
> 幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样

#### 隔离机制  

1. 未提交读  
> 事务中的修改，即时没有提交，对其他会话也是可见的。  
> 事务最低的隔离级别，可以读取未提交的数据--**脏读**，一般不使用这个隔离级别。  

2. 提交读或不可重复读  
> 在事务未完成commit操作之前修改的数据对其他Session的事务不可见，执行了commit之后才会对其他Session 可见。   
> 解决了脏读的问题，但是会对其他session产生两次不一致的读取结果（commit提交事务之前和之后），即**幻读**。  

3. 可重复读  
> 一个事务中多次执行同一读SQL,返回结果一样。   
> 这个隔离级别解决了脏读的问题，但会出现幻读问题，是``mysql``默认的事务隔离级别。  

4. 可串行化   
> 最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是会导致大量超时以及锁争用问题。  

### 死锁  

死锁，就是产生了循环等待链条，我等待你的资源，你却等待我的资源，我们都相互等待，谁也不释放自己占有的资源，导致无线等待下去。  

* 如何尽可能避免死锁  
> 大事务拆分  
> 降低隔离级别，从RR调整为RC级别

解决方案：  

* ``innodb_lock_wait_timeout``等待锁超时回滚事务：  

* ``wait-for graph``算法来主动进行死锁检测： 


### 引擎InnoDB和MyISAM   

* Innodb引擎  
> Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。  

* MyIASM引擎  
> MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。  

* 主要区别  
1、MyIASM是非事务安全的，而InnoDB是事务安全的
2、MyIASM锁的粒度是表级的，而InnoDB支持行级锁
3、MyIASM支持全文类型索引，而InnoDB不支持全文索引
4、MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM
5、MyIASM表保存成文件形式，跨平台使用更加方便  

* 应用场景  
1、MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM
2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB

## sql优化  

参考博客：<https://github.com/crossoverJie/JCSprout/blob/master/MD/SQL-optimization.md>  

# 网络通信  

参考：[一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）](https://www.jianshu.com/p/9f3e879a4c9c)  

## OSI七层模型和TCP/IP四层  

![](1)

## TCP三次握手四次挥手  

1. TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。  
2. 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。  
3. 在socket编程中，这一过程由客户端执行connect来触发。  

![](2)

# Spring IOC和AOP原理  

## IOC   

``IOC``：控制反转也叫依赖注入。利用了工厂模式。  
> 将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。  
> 在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。  

## AOP  

1. AOP可以说是对OOP的补充和完善。  
2. OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。  
3. 当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。  
4. 也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。  
> 例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。  

### 实现原理  

实现AOP的技术，主要分为两大类：  
1. 一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；  
2. 二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。  

如果面试官硬要给你扯原理，你也跟他扯。  

所以必须得深化点，你得告诉他，aop实现原理其实是java动态代理，但是jdk的动态代理必须实现接口，所以spring的aop是用cglib这个库实现的，cglib使用了asm这个直接操纵字节码的框架，所以可以做到不实现接口的情况下完成动态代理。
最好拿张纸手写两个例子给他，然后他就没什么好问的了。  



